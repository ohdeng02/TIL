# 코딩테스트 연습

## 1) 최소신장트리(mst)

- 사이클 형성 및 포함되면 안 됨
- 모든 n개의 정점은 반드시 n-1개의 간선 연결구성, 무방향 그래프
- 여러개의 신장트리 존재할 수 있음(그 중에서 가중치가 최소인게 최소신장트리)
    
    ### 크루스칼 알고리즘(간선기준)
    
    - 최소비용간선구성, 최소 개수 간선 연결
    - 사이클x
    - 이전 신장트리와 상관없이 무조건 최소 간선 선택
    - 1. 간선들 가중치 순으로 오름차순 정렬.
    - 2. 사이클이 형성되지 않는 간선을 선택.(낮은 가중치부터 선택)
    - 3. 선택된 간선 트리에 추가
    - G=graph, E=edge, V=vertax(정점)   시간복잡도?
    
    ```objectivec
    KRUSKAL(G)
    	for vertex v in (G.V):
    		make set(v)
    		sort the edge of G.E for nondecreasing order by weight w
    
    	for each edge (u, v) in G.E take in nondecreasing order by weight
    		if find(u) != find (v):
    			union(u, v)
    			list = list U {(u, v)}
    
    	return list
    ```
    
    - 간선 시작점과 끝점의 최상위 포인트를 비교해 같지 않으면 해당 간선 선택(사이클이 아닌 경우)
    - Union&Find 알고리즘 이용
 

``` java

import java.io.*;
import java.util.*;

class Edge implements Comparable<Edge> {

    private int distance;
    private int nodeA;
    private int nodeB;

    public Edge(int distance, int nodeA, int nodeB) {
        this.distance = distance;
        this.nodeA = nodeA;
        this.nodeB = nodeB;
    }
    public int getDistance() {
        return this.distance;
    }
    public void setDistance(int distance){
        this.distance = distance;
    }
    public int getNodeA() {
        return this.nodeA;
    }
    public int getNodeB() {
        return this.nodeB;
    }

    @Override
    public String toString() {
        return "(" + distance + ", "
                   + (char)(nodeA+64) + ", "
                   + (char)(nodeB+64) + ", "
                + ")";
    }
    @Override
    public int compareTo(Edge other) {
        if (this.distance < other.distance) {
            return -1;
        }
        return 1;
    }
}

public class KuruskalAlgorithm {

    public static int[] parent; // 부모 테이블 선언
    // 모든 간선을 담을 리스트와, 최종 비용을 담을 변수
    public static ArrayList<Edge> edges = new ArrayList<>();
    public static int result = 0;

    public static int find(int x) {
        if(parent[x] == x) return x;
        return find(parent[x]);
    }
    public static void union(int x, int y) {
        x = find(x);
        y = find(y);
        if(x < y) parent[y] = x;
        else parent[x] = y;
    }

    public static void quickSort(int start, int end) {
        if (start >= end) {
            return;
        }

        int pivot = start + (end - start) / 2;
        int pivotValue = edges.get(pivot).getDistance();

        int left = start;
        int right = end;
        while (left <= right) {
            while (edges.get(left).getDistance() < pivotValue) {
                left++;
            }

            while (edges.get(right).getDistance() > pivotValue) {
                right--;
            }

            if (left <= right) {
                int tmp = edges.get(right).getDistance();
                edges.get(right).setDistance(edges.get(left).getDistance());
                edges.get(left).setDistance(tmp);
                left++;
                right--;
            }
        }
        quickSort(start, right);
        quickSort(start, end);
    }

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();

        int v = Integer.parseInt(st.nextToken());
        int e = Integer.parseInt(st.nextToken());

        st = new StringTokenizer(br.readLine());
        List<Character> nodes = new ArrayList<>();
        for (int i=0; i<v; i++) { nodes.add(st.nextToken().charAt(0)); }

        for (int i=0; i<e; i++){
            st = new StringTokenizer(br.readLine());
            int cost = Integer.parseInt(st.nextToken());
            int a = (int)(st.nextToken().charAt(0))-64;
            int b = (int)(st.nextToken().charAt(0))-64;
            edges.add(new Edge(cost, a, b));
        }

        // 부모 테이블상에서, 부모를 자기 자신으로 초기화
        for (int i = 1; i <= v; i++) {
            parent[i] = i;
        }

        // 간선을 비용순으로 정렬
        quickSort(0, edges.size()-1);

        // 간선을 하나씩 확인하며
        for (int i = 0; i < edges.size(); i++) {
            int a = edges.get(i).getNodeA();
            int b = edges.get(i).getNodeB();
            // 사이클이 발생하지 않는 경우에만 집합에 포함
            if (find(a) != find(b)) {
                union(a, b);
                sb.append(edges.get(i).toString()+"\n");
            }
        }

        bw.write(sb.toString());
        bw.flush();
    }
}

```

## 2) 최단경로

- 한 정점에서 모든 정점까지의 최단거리
- 그래프 방향 유무등은 상관없음. 가중치가 음수(뒤로 돌아가는 경우)이면 안 됨.
    
    ### 다익스트라 알고리즘(노드기준)
    
    - greedy와 동적계획법이 병합된 형태
    - 시간복잡도가 비교적 늘어날 수 있음
    - 큐+스택 = 힙
    - 시간복잡도 O(nlogn)을 해결하기 위해 힙사용
