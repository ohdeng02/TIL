# 코딩테스트 연습 (크루스칼 알고리즘)

- 정점들과 간선, 비용들을 입력
- 최소 비용의 간선을 비용이 적은 순대로 출력

``` java
package org.example.keaCodingtest;

import java.io.*;
import java.util.*;

class Edge implements Comparable<Edge> { // 간선에 대한 내용을 담을 클래스 선언

    private int distance;  // 해당 간선의 이동 비용에 대한 속성
    private int nodeA; // 해당 간선의 시작 노드에 대한 속성
    private int nodeB; // 헤딩 간선의 끝 노드에 대한 속성

    public Edge(int distance, int nodeA, int nodeB) { // 간선 클래스 생성자
        this.distance = distance;
        this.nodeA = nodeA;
        this.nodeB = nodeB;
    }
    // 해당 간선의 이동 비용을 반환
    public int getDistance() { return this.distance; }
    // 해당 간선의 이동 비용을 설정
    public void setDistance(int distance){ this.distance = distance; }
    // 해당 간선의 시작 노드 값을 반환
    public int getNodeA() { return this.nodeA; }
    // 해당 간선의 끝 노드 값을 반환
    public int getNodeB() { return this.nodeB; }

    @Override
    // 간선의 이동 비용, 시작 노드, 끝 노드를 출력하기 위한 메서드
    public String toString() {
        return "(" + distance + ", "
                   + (char)(nodeA+65) + ", "
                   + (char)(nodeB+65) + ")";
    }
    @Override
    // 사용하지는 않지만 값을 비교하기 위한 메서드
    public int compareTo(Edge other) {
        if (this.distance < other.distance) {
            return -1;
        }
        return 1;
    }
}

public class KuruskalAlgorithm {

    static int[] parent; // 부모 테이블 선언
    // 모든 간선을 담을 리스트 선언
    static ArrayList<Edge> edges = new ArrayList<>();

    // 간선의 부모를 찾는 함수
    public static int find(int x) {
        if(parent[x] == x) return x; // 부모가 자신인 정점을 찾으면 해당 정점이 루트노드이므로 반환
        return find(parent[x]); // 부모인 정점을 찾을 때까지 해당 함수를 반복(재귀함수)
    }
    // 두 정점의 부모를 같게 만들어 같은 집합에 들어가도록 합치는 함수
    public static void union(int x, int y) {
        x = find(x); // 해당 정점의 부모 찾기
        y = find(y); // 해당 정점의 부모 찾기
        if(x < y) parent[y] = x; // 부모를 같게 해서 같은 두 정점을 합집합
        else parent[x] = y;
    }


    public static void quickSort(int start, int end) { //퀵 정렬 알고리즘
    // start가 end보다 크거나 같다면 정렬할 원소가 1개 이하이므로 정렬하지 않고 반환
    if (start >= end)
        return;

    // 가장 왼쪽의 값을 pivot으로 지정하고 실제 비교 검사는 start+1 부터 시작
    int pivot = start;
    int lo = start + 1;
    int hi = end; // 정렬의 마지막 값 지정

    // lo는 현재 부분배열의 왼쪽, hi는 오른쪽을 의미
    // lo가 hi보다 커질 경우 while문 종료
    while (lo <= hi) {
        while (lo <= end && edges.get(lo).getDistance() <= edges.get(pivot).getDistance()) // 피벗보다 큰 값을 만날 때까지
            lo++;
        while (hi > start && edges.get(hi).getDistance() >= edges.get(pivot).getDistance()) // 피벗보다 작은 값을 만날 때까지
            hi--;
        if (lo > hi) { // 엇갈리면 피벗과 교체
            Edge tmp = edges.get(hi);
            edges.set(hi, edges.get(pivot));
            edges.set(pivot, tmp);
        }
        else {
            // 엇갈리지 않으면 lo, hi 값 교체
            Edge tmp = edges.get(lo);
            edges.set(lo, edges.get(hi));
            edges.set(hi, tmp);
        }
    }

    // 엇갈렸을 경우,
    // 피벗값과 hi값을 교체한 후 해당 피벗을 기준으로 앞 뒤로 배열을 분할하여 정렬 진행
    quickSort(start, hi - 1);
    quickSort(hi + 1, end);

    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();

        int v = Integer.parseInt(st.nextToken());
        int e = Integer.parseInt(st.nextToken());

        st = new StringTokenizer(br.readLine());
        List<Character> nodes = new ArrayList<>();
        for (int i=0; i<v; i++) { nodes.add(st.nextToken().charAt(0)); }

        for (int i=0; i<e; i++){
            st = new StringTokenizer(br.readLine());
            int cost = Integer.parseInt(st.nextToken());
            int a = (int)(st.nextToken().charAt(0))-65;
            int b = (int)(st.nextToken().charAt(0))-65;
            edges.add(new Edge(cost, a, b));
        }

        // 부모 테이블상에서, 부모를 자기 자신으로 초기화
        parent = new int[v];
        for (int i = 0; i < v; i++) {
            parent[i] = i;
        }

        // 간선을 비용순으로 정렬
        quickSort(0, edges.size()-1);

        // 간선을 하나씩 확인하며
        for (int i = 0; i < edges.size(); i++) {
            int a = edges.get(i).getNodeA();
            int b = edges.get(i).getNodeB();
            // 사이클이 발생하지 않는 경우에만 집합에 포함
            if (find(a) != find(b)) {
                union(a, b);
                sb.append(edges.get(i).toString()+"\n");
            }
        }

        bw.write(sb.toString());
        bw.flush();
    }
}
```
